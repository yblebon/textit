<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Encrypted Message + Fingerprint (Config from file)</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
  body {font-family:system-ui,sans-serif;margin:0;background:#f0f2f5;padding:20px;}
  .container {max-width:920px;margin:0 auto;background:white;border-radius:16px;box-shadow:0 12px 40px rgba(0,0,0,0.1);overflow:hidden;}
  .tabs {display:flex;background:#1a1a2e;}
  .tab {flex:1;padding:20px;text-align:center;color:#aaa;cursor:pointer;font-weight:600;transition:.3s;}
  .tab.active {background:#0f3460;color:white;}
  .content {padding:40px;display:none;}
  .content.active {display:block;}
  textarea, input[type=password] {width:100%;padding:14px;margin:12px 0;border:1px solid #ccc;border-radius:10px;font-size:15px;box-sizing:border-box;}
  textarea {height:160px;resize:vertical;font-family:monospace;}
  button {background:#0f3460;color:white;border:none;padding:14px 32px;border-radius:10px;font-size:16px;cursor:pointer;}
  button:disabled {background:#666;cursor:not-allowed;}
  .pw {position:relative;}
  .eye {position:absolute;right:12px;top:50%;transform:translateY(-50%);background:none;border:none;font-size:20px;cursor:pointer;}
  .result {margin-top:20px;padding:18px;background:#f8f9fc;border-radius:10px;font-family:monospace;font-size:13.5px;max-height:420px;overflow:auto;white-space:pre-wrap;word-break:break-all;border:1px solid #e0e0e0;}
  .error {color:#c33;margin-top:10px;}
  .warning {background:#fff3cd;color:#856404;padding:12px;border-radius:8px;margin:15px 0;font-size:0.95em;}
</style>
</head>
<body>

<div class="container">
  <div class="tabs">
    <div class="tab active" data-tab="encrypt">Encrypt</div>
    <div class="tab" data-tab="decrypt">Decrypt</div>
  </div>

  <div id="status" class="warning" style="margin:20px;display:none;"></div>

  <div id="encrypt" class="content active">
    <h2>Encrypt Message + Device Fingerprint</h2>
    <textarea id="msg" placeholder="Your secret message..."></textarea>

    <label>Password</label>
    <div class="pw"><input type="password" id="pass1"><button class="eye" onclick="toggle('pass1')">Eye</button></div>

    <label>Confirm Password</label>
    <div class="pw"><input type="password" id="pass2"><button class="eye" onclick="toggle('pass2')">Eye</button></div>

    <button id="encBtn" onclick="encryptMessage()" disabled>Encrypt (config-loaded)</button>

    <div id="encResult" class="result" style="display:none;"></div>
    <div id="encError" class="error"></div>
  </div>

  <div id="decrypt" class="content">
    <h2>Decrypt Message</h2>
    <textarea id="encInput" placeholder="Paste encrypted string..."></textarea>

    <label>Password</label>
    <div class="pw"><input type="password" id="decPass"><button class="eye" onclick="toggle('decPass')">Eye</button></div>

    <button onclick="decryptMessage()">Decrypt</button>

    <div id="decResult" class="result" style="display:none;"></div>
    <div id="decError" class="error"></div>
  </div>
</div>

<script>
// Default fallback config (used if config.json is missing or blocked)
const DEFAULT_CONFIG = {
  crypto: {
    algorithm: "AES-GCM",
    keyLength: 256,
    pbkdf2: { name: "PBKDF2", hash: "SHA-256", iterations: 600000, saltBytes: 16 },
    ivBytes: 12
  },
  outputFormat: "base64", // "base64" or "hex"
  collect: {
    message: true, timestamp: true, userAgent: true, language: true,
    platform: true, screen: true, timezone: true, ip: true, location: true
  },
  apis: { ip: "https://api.ipify.org?format=json" }
};

let CONFIG = { ...DEFAULT_CONFIG };

async function loadConfig() {
  try {
    const res = await fetch('config.json?' + Date.now()); // cache buster
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    const loaded = await res.json();
    CONFIG = deepMerge(DEFAULT_CONFIG, loaded);
    document.getElementById('status').style.display = 'none';
  } catch (err) {
    console.warn("Could not load config.json → using defaults", err);
    document.getElementById('status').textContent =
      "Warning: config.json not found or blocked (CORS/local file issue). Using built-in defaults.";
    document.getElementById('status').style.display = 'block';
  }
}

// Simple deep merge (sufficient for this use case)
function deepMerge(target, source) {
  const result = { ...target };
  for (const key in source) {
    if (source[key] && typeof source[key] === 'object' && !Array.isArray(source[key])) {
      result[key] = deepMerge(target[key] || {}, source[key]);
    } else {
      result[key] = source[key];
    }
  }
  return result;
}

// Load config first
loadConfig().then(() => {
  // Enable UI after config is ready
  document.querySelectorAll('.tab').forEach(t => t.addEventListener('click', () => openTab(t.dataset.tab)));
  document.getElementById('pass1').addEventListener('input', checkPw);
  document.getElementById('pass2').addEventListener('input', checkPw);
});

function openTab(tab) {
  document.querySelectorAll('.content').forEach(c => c.classList.remove('active'));
  document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
  document.getElementById(tab).classList.add('active');
  document.querySelector(`.tab[data-tab="${tab}"]`).classList.add('active');
}

function toggle(id) {
  const el = document.getElementById(id);
  el.type = el.type === 'password' ? 'text' : 'password';
}

function checkPw() {
  const ok = document.getElementById('pass1').value &&
             document.getElementById('pass1').value === document.getElementById('pass2').value;
  document.getElementById('encBtn').disabled = !ok;
}

// Same collect/encrypt/decrypt logic as before, now using CONFIG
async function collectData() {
  const d = {};
  if (CONFIG.collect.message) d.message = document.getElementById('msg').value.trim();
  if (CONFIG.collect.timestamp) d.timestamp = new Date().toISOString();
  if (CONFIG.collect.userAgent) d.userAgent = navigator.userAgent;
  if (CONFIG.collect.language) d.language = navigator.language || navigator.languages;
  if (CONFIG.collect.platform) d.platform = navigator.platform;
  if (CONFIG.collect.screen) d.screen = `${screen.width}x${screen.height}x${screen.colorDepth}`;
  if (CONFIG.collect.timezone) d.timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
  if (CONFIG.collect.ip) {
    try {
      const r = await fetch(CONFIG.apis.ip);
      d.ip = (await r.json()).ip || await r.text();
    } catch(e) { d.ip = "unavailable"; }
  }
  if (CONFIG.collect.location && navigator.geolocation) {
    try {
      const pos = await new Promise((res, rej) => navigator.geolocation.getCurrentPosition(res, rej, {timeout:8000}));
      d.location = {lat: pos.coords.latitude, lon: pos.coords.longitude, acc: pos.coords.accuracy};
    } catch(e) { d.location = "denied"; }
  }
  return d;
}

async function encryptMessage() {
  const password = document.getElementById('pass1').value;
  const result = document.getElementById('encResult');
  const err = document.getElementById('encError');
  result.style.display = 'none'; err.textContent = '';

  try {
    const payload = await collectData();
    const json = JSON.stringify(payload, null, 2);

    const salt = crypto.getRandomValues(new Uint8Array(CONFIG.crypto.pbkdf2.saltBytes));
    const iv = crypto.getRandomValues(new Uint8Array(CONFIG.crypto.ivBytes));

    const key = await crypto.subtle.deriveKey(
      {name:"PBKDF2", salt, iterations:CONFIG.crypto.pbkdf2.iterations, hash:CONFIG.crypto.pbkdf2.hash},
      await crypto.subtle.importKey("raw", new TextEncoder().encode(password), "PBKDF2", false, ["deriveKey"]),
      {name:CONFIG.crypto.algorithm, length:CONFIG.crypto.keyLength},
      false, ["encrypt"]
    );

    const encrypted = await crypto.subtle.encrypt({name:CONFIG.crypto.algorithm, iv}, key, new TextEncoder().encode(json));

    const combined = new Uint8Array(salt.byteLength + iv.byteLength + encrypted.byteLength);
    combined.set(salt); combined.set(iv, salt.byteLength); combined.set(new Uint8Array(encrypted), salt.byteLength + iv.byteLength);

    const output = CONFIG.outputFormat === "hex"
      ? Array.from(combined).map(b=>b.toString(16).padStart(2,'0')).join('')
      : btoa(String.fromCharCode(...combined));

    result.textContent = output;
    result.style.display = 'block';
  } catch (e) {
    err.textContent = "Encryption failed: " + e.message;
  }
}

async function decryptMessage() {
  const input = document.getElementById('encInput').value.trim();
  const password = document.getElementById('decPass').value;
  const result = document.getElementById('decResult');
  const err = document.getElementById('decError');
  result.style.display = 'none'; err.textContent = '';

  if (!input || !password) return err.textContent = "Missing data/password";

  try {
    let data;
    if (CONFIG.outputFormat === "hex") {
      data = Uint8Array.from(input.match(/.{1,2}/g).map(b=>parseInt(b,16)));
    } else {
      data = Uint8Array.from(atob(input), c=>c.charCodeAt(0));
    }

    const salt = data.slice(0, CONFIG.crypto.pbkdf2.saltBytes);
    const iv = data.slice(CONFIG.crypto.pbkdf2.saltBytes, CONFIG.crypto.pbkdf2.saltBytes + CONFIG.crypto.ivBytes);
    const ct = data.slice(CONFIG.crypto.pbkdf2.saltBytes + CONFIG.crypto.ivBytes);

    const key = await crypto.subtle.deriveKey(
      {name:"PBKDF2", salt, iterations:CONFIG.crypto.pbkdf2.iterations, hash:CONFIG.crypto.pbkdf2.hash},
      await crypto.subtle.importKey("raw", new TextEncoder().encode(password), "PBKDF2", false, ["deriveKey"]),
      {name:CONFIG.crypto.algorithm, length:CONFIG.crypto.keyLength},
      false, ["decrypt"]
    );

    const plain = await crypto.subtle.decrypt({name:CONFIG.crypto.algorithm, iv}, key, ct);
    result.textContent = new TextDecoder().decode(plain);
    result.style.display = 'block';
  } catch (e) {
    err.textContent = "Decryption failed — wrong password or corrupted data";
  }
}
</script>

</body>
</html>